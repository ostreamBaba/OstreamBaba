## jdk bug库* JDK-6260652 : (coll) Arrays.asList(x).toArray().getClass() should be Object[].class``` public ArrayList(Collection<? extends E> c) {        elementData = c.toArray();        if ((size = elementData.length) != 0) {            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        } else {            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        }    }```* 关于 c.toArray might (incorrectly) not return Object[] (see 6260652)这里是指 c.toArray返回的数组类型不一定是Object[]* 造成这个原因的问题是 List.toArray的实现不一样。```List<String> list=new java.util.ArrayList<String>(Arrays.asList("123","456"));List<String> list1=Arrays.asList("123","456");System.out.println(list.getClass()); //class java.util.ArrayListSystem.out.println(list1.getClass()); //class java.util.Arrays$ArrayList``````toArray 方法返回的依然是 Object[]，但是与java.util.ArrayList不同的是这里底层存储是泛型类型的数组 private final E[] a，所以保留了实际的类型public static void test(){Object[] objs = new String[1]; System.out.println( objs.getClass() ); //class [Ljava.lang.String;Object[] objs2 = new Object[1];objs2[0] = new String();System.out.println( objs2.getClass() ); //class [Ljava.lang.Object;}这样子可能更直观：Array toArray的运行：public static void test4(){String[] strings = {new String(),new String()};Object[] objects = (Object[]) strings.clone();System.out.println(objects.getClass()); //class [Ljava.lang.String;}```- [直接丢blog的链接吧](https://blog.csdn.net/viscu/article/details/80313028)